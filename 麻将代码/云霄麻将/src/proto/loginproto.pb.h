// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loginproto.proto

#ifndef PROTOBUF_loginproto_2eproto__INCLUDED
#define PROTOBUF_loginproto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {
namespace login {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_loginproto_2eproto();
void protobuf_AssignDesc_loginproto_2eproto();
void protobuf_ShutdownFile_loginproto_2eproto();

class ReqLogin;
class ReqLogout;
class ReqReady;
class ReqTableAction;
class ReqHeatBeat;
class AllLookOnUserReq;
class ReqEmotion;
class AckLoginSuccessUc;
class AckLoginSuccessBc;
class AckLoginError;
class AckGPS;
class tagPlayers;
class AckTableInfo;
class AckLogoutBc;
class AckUpTableSuccess;
class AckUpTableErrorUc;
class AckAheadDownTable;
class AckDownTableSuccess;
class AckUpTableInfoReq;
class AckUpTableInfo_UC;
class AckUpTableInfo_BC;
class AckAllLookOnUserResp;
class AckHeatBeat;
class AckPrereadyBC;
class AckEmotionBC;
class AckChatBC;

// ===================================================================

class ReqLogin : public ::google::protobuf::Message {
 public:
  ReqLogin();
  virtual ~ReqLogin();

  ReqLogin(const ReqLogin& from);

  inline ReqLogin& operator=(const ReqLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogin& default_instance();

  void Swap(ReqLogin* other);

  // implements Message ----------------------------------------------

  ReqLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLogin& from);
  void MergeFrom(const ReqLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional string skey = 4;
  inline bool has_skey() const;
  inline void clear_skey();
  static const int kSkeyFieldNumber = 4;
  inline const ::std::string& skey() const;
  inline void set_skey(const ::std::string& value);
  inline void set_skey(const char* value);
  inline void set_skey(const char* value, size_t size);
  inline ::std::string* mutable_skey();
  inline ::std::string* release_skey();
  inline void set_allocated_skey(::std::string* skey);

  // optional int32 roomid = 5;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 5;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);

  // optional string deviceId = 6;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 6;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional int32 base_money = 7;
  inline bool has_base_money() const;
  inline void clear_base_money();
  static const int kBaseMoneyFieldNumber = 7;
  inline ::google::protobuf::int32 base_money() const;
  inline void set_base_money(::google::protobuf::int32 value);

  // optional int32 stand_money = 8;
  inline bool has_stand_money() const;
  inline void clear_stand_money();
  static const int kStandMoneyFieldNumber = 8;
  inline ::google::protobuf::int32 stand_money() const;
  inline void set_stand_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.ReqLogin)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_skey();
  inline void clear_has_skey();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_base_money();
  inline void clear_has_base_money();
  inline void set_has_stand_money();
  inline void clear_has_stand_money();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* skey_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 roomid_;
  ::std::string* deviceid_;
  ::google::protobuf::int32 base_money_;
  ::google::protobuf::int32 stand_money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static ReqLogin* default_instance_;
};
// -------------------------------------------------------------------

class ReqLogout : public ::google::protobuf::Message {
 public:
  ReqLogout();
  virtual ~ReqLogout();

  ReqLogout(const ReqLogout& from);

  inline ReqLogout& operator=(const ReqLogout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogout& default_instance();

  void Swap(ReqLogout* other);

  // implements Message ----------------------------------------------

  ReqLogout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLogout& from);
  void MergeFrom(const ReqLogout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.ReqLogout)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static ReqLogout* default_instance_;
};
// -------------------------------------------------------------------

class ReqReady : public ::google::protobuf::Message {
 public:
  ReqReady();
  virtual ~ReqReady();

  ReqReady(const ReqReady& from);

  inline ReqReady& operator=(const ReqReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqReady& default_instance();

  void Swap(ReqReady* other);

  // implements Message ----------------------------------------------

  ReqReady* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqReady& from);
  void MergeFrom(const ReqReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 seatid = 2;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 2;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.ReqReady)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seatid();
  inline void clear_has_seatid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 seatid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static ReqReady* default_instance_;
};
// -------------------------------------------------------------------

class ReqTableAction : public ::google::protobuf::Message {
 public:
  ReqTableAction();
  virtual ~ReqTableAction();

  ReqTableAction(const ReqTableAction& from);

  inline ReqTableAction& operator=(const ReqTableAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqTableAction& default_instance();

  void Swap(ReqTableAction* other);

  // implements Message ----------------------------------------------

  ReqTableAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqTableAction& from);
  void MergeFrom(const ReqTableAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 roomid = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 2;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.ReqTableAction)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static ReqTableAction* default_instance_;
};
// -------------------------------------------------------------------

class ReqHeatBeat : public ::google::protobuf::Message {
 public:
  ReqHeatBeat();
  virtual ~ReqHeatBeat();

  ReqHeatBeat(const ReqHeatBeat& from);

  inline ReqHeatBeat& operator=(const ReqHeatBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqHeatBeat& default_instance();

  void Swap(ReqHeatBeat* other);

  // implements Message ----------------------------------------------

  ReqHeatBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqHeatBeat& from);
  void MergeFrom(const ReqHeatBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.ReqHeatBeat)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static ReqHeatBeat* default_instance_;
};
// -------------------------------------------------------------------

class AllLookOnUserReq : public ::google::protobuf::Message {
 public:
  AllLookOnUserReq();
  virtual ~AllLookOnUserReq();

  AllLookOnUserReq(const AllLookOnUserReq& from);

  inline AllLookOnUserReq& operator=(const AllLookOnUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllLookOnUserReq& default_instance();

  void Swap(AllLookOnUserReq* other);

  // implements Message ----------------------------------------------

  AllLookOnUserReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllLookOnUserReq& from);
  void MergeFrom(const AllLookOnUserReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 start_index = 1;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 1;
  inline ::google::protobuf::int32 start_index() const;
  inline void set_start_index(::google::protobuf::int32 value);

  // optional int32 end_index = 2;
  inline bool has_end_index() const;
  inline void clear_end_index();
  static const int kEndIndexFieldNumber = 2;
  inline ::google::protobuf::int32 end_index() const;
  inline void set_end_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AllLookOnUserReq)
 private:
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_end_index();
  inline void clear_has_end_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 start_index_;
  ::google::protobuf::int32 end_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AllLookOnUserReq* default_instance_;
};
// -------------------------------------------------------------------

class ReqEmotion : public ::google::protobuf::Message {
 public:
  ReqEmotion();
  virtual ~ReqEmotion();

  ReqEmotion(const ReqEmotion& from);

  inline ReqEmotion& operator=(const ReqEmotion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEmotion& default_instance();

  void Swap(ReqEmotion* other);

  // implements Message ----------------------------------------------

  ReqEmotion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqEmotion& from);
  void MergeFrom(const ReqEmotion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 target_seatid = 2;
  inline bool has_target_seatid() const;
  inline void clear_target_seatid();
  static const int kTargetSeatidFieldNumber = 2;
  inline ::google::protobuf::int32 target_seatid() const;
  inline void set_target_seatid(::google::protobuf::int32 value);

  // optional int32 target_seat_num = 3;
  inline bool has_target_seat_num() const;
  inline void clear_target_seat_num();
  static const int kTargetSeatNumFieldNumber = 3;
  inline ::google::protobuf::int32 target_seat_num() const;
  inline void set_target_seat_num(::google::protobuf::int32 value);

  // optional int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.ReqEmotion)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_target_seatid();
  inline void clear_has_target_seatid();
  inline void set_has_target_seat_num();
  inline void clear_has_target_seat_num();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 target_seatid_;
  ::google::protobuf::int32 target_seat_num_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static ReqEmotion* default_instance_;
};
// -------------------------------------------------------------------

class AckLoginSuccessUc : public ::google::protobuf::Message {
 public:
  AckLoginSuccessUc();
  virtual ~AckLoginSuccessUc();

  AckLoginSuccessUc(const AckLoginSuccessUc& from);

  inline AckLoginSuccessUc& operator=(const AckLoginSuccessUc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLoginSuccessUc& default_instance();

  void Swap(AckLoginSuccessUc* other);

  // implements Message ----------------------------------------------

  AckLoginSuccessUc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLoginSuccessUc& from);
  void MergeFrom(const AckLoginSuccessUc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional string avatar = 2;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 2;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // optional int32 coin = 3;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 3;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // optional int32 exp = 4;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 4;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 money = 5;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 5;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 ready = 7;
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 7;
  inline ::google::protobuf::int32 ready() const;
  inline void set_ready(::google::protobuf::int32 value);

  // optional int32 rmb = 8;
  inline bool has_rmb() const;
  inline void clear_rmb();
  static const int kRmbFieldNumber = 8;
  inline ::google::protobuf::int32 rmb() const;
  inline void set_rmb(::google::protobuf::int32 value);

  // optional int32 see = 9;
  inline bool has_see() const;
  inline void clear_see();
  static const int kSeeFieldNumber = 9;
  inline ::google::protobuf::int32 see() const;
  inline void set_see(::google::protobuf::int32 value);

  // optional int32 sex = 10;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 10;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional int32 total_board = 11;
  inline bool has_total_board() const;
  inline void clear_total_board();
  static const int kTotalBoardFieldNumber = 11;
  inline ::google::protobuf::int32 total_board() const;
  inline void set_total_board(::google::protobuf::int32 value);

  // optional int32 total_win = 12;
  inline bool has_total_win() const;
  inline void clear_total_win();
  static const int kTotalWinFieldNumber = 12;
  inline ::google::protobuf::int32 total_win() const;
  inline void set_total_win(::google::protobuf::int32 value);

  // optional int32 uid = 13;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 13;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 vlevel = 14;
  inline bool has_vlevel() const;
  inline void clear_vlevel();
  static const int kVlevelFieldNumber = 14;
  inline ::google::protobuf::int32 vlevel() const;
  inline void set_vlevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckLoginSuccessUc)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ready();
  inline void clear_has_ready();
  inline void set_has_rmb();
  inline void clear_has_rmb();
  inline void set_has_see();
  inline void clear_has_see();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_total_board();
  inline void clear_has_total_board();
  inline void set_has_total_win();
  inline void clear_has_total_win();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_vlevel();
  inline void clear_has_vlevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* avatar_;
  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 money_;
  ::std::string* name_;
  ::google::protobuf::int32 ready_;
  ::google::protobuf::int32 rmb_;
  ::google::protobuf::int32 see_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 total_board_;
  ::google::protobuf::int32 total_win_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 vlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckLoginSuccessUc* default_instance_;
};
// -------------------------------------------------------------------

class AckLoginSuccessBc : public ::google::protobuf::Message {
 public:
  AckLoginSuccessBc();
  virtual ~AckLoginSuccessBc();

  AckLoginSuccessBc(const AckLoginSuccessBc& from);

  inline AckLoginSuccessBc& operator=(const AckLoginSuccessBc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLoginSuccessBc& default_instance();

  void Swap(AckLoginSuccessBc* other);

  // implements Message ----------------------------------------------

  AckLoginSuccessBc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLoginSuccessBc& from);
  void MergeFrom(const AckLoginSuccessBc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string avatar = 5;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 5;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // optional int32 sex = 6;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 6;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckLoginSuccessBc)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_sex();
  inline void clear_has_sex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 uid_;
  ::std::string* name_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 sex_;
  ::std::string* avatar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckLoginSuccessBc* default_instance_;
};
// -------------------------------------------------------------------

class AckLoginError : public ::google::protobuf::Message {
 public:
  AckLoginError();
  virtual ~AckLoginError();

  AckLoginError(const AckLoginError& from);

  inline AckLoginError& operator=(const AckLoginError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLoginError& default_instance();

  void Swap(AckLoginError* other);

  // implements Message ----------------------------------------------

  AckLoginError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLoginError& from);
  void MergeFrom(const AckLoginError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckLoginError)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckLoginError* default_instance_;
};
// -------------------------------------------------------------------

class AckGPS : public ::google::protobuf::Message {
 public:
  AckGPS();
  virtual ~AckGPS();

  AckGPS(const AckGPS& from);

  inline AckGPS& operator=(const AckGPS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGPS& default_instance();

  void Swap(AckGPS* other);

  // implements Message ----------------------------------------------

  AckGPS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckGPS& from);
  void MergeFrom(const AckGPS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional double latitude = 2;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  inline double latitude() const;
  inline void set_latitude(double value);

  // optional double longitude = 3;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 3;
  inline double longitude() const;
  inline void set_longitude(double value);

  // optional string city = 4;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 4;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // @@protoc_insertion_point(class_scope:proto.login.AckGPS)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_city();
  inline void clear_has_city();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double latitude_;
  double longitude_;
  ::std::string* city_;
  ::google::protobuf::int32 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckGPS* default_instance_;
};
// -------------------------------------------------------------------

class tagPlayers : public ::google::protobuf::Message {
 public:
  tagPlayers();
  virtual ~tagPlayers();

  tagPlayers(const tagPlayers& from);

  inline tagPlayers& operator=(const tagPlayers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tagPlayers& default_instance();

  void Swap(tagPlayers* other);

  // implements Message ----------------------------------------------

  tagPlayers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tagPlayers& from);
  void MergeFrom(const tagPlayers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 seatid = 2;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 2;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 ready = 3;
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 3;
  inline ::google::protobuf::int32 ready() const;
  inline void set_ready(::google::protobuf::int32 value);

  // optional int32 money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 sex = 6;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 6;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional string avatar = 7;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 7;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // optional .proto.login.AckGPS GPS = 8;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGPSFieldNumber = 8;
  inline const ::proto::login::AckGPS& gps() const;
  inline ::proto::login::AckGPS* mutable_gps();
  inline ::proto::login::AckGPS* release_gps();
  inline void set_allocated_gps(::proto::login::AckGPS* gps);

  // @@protoc_insertion_point(class_scope:proto.login.tagPlayers)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_ready();
  inline void clear_has_ready();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_gps();
  inline void clear_has_gps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 ready_;
  ::google::protobuf::int32 money_;
  ::std::string* name_;
  ::std::string* avatar_;
  ::proto::login::AckGPS* gps_;
  ::google::protobuf::int32 sex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static tagPlayers* default_instance_;
};
// -------------------------------------------------------------------

class AckTableInfo : public ::google::protobuf::Message {
 public:
  AckTableInfo();
  virtual ~AckTableInfo();

  AckTableInfo(const AckTableInfo& from);

  inline AckTableInfo& operator=(const AckTableInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckTableInfo& default_instance();

  void Swap(AckTableInfo* other);

  // implements Message ----------------------------------------------

  AckTableInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckTableInfo& from);
  void MergeFrom(const AckTableInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 stand_money = 3;
  inline bool has_stand_money() const;
  inline void clear_stand_money();
  static const int kStandMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 stand_money() const;
  inline void set_stand_money(::google::protobuf::int32 value);

  // optional int32 base_money = 4;
  inline bool has_base_money() const;
  inline void clear_base_money();
  static const int kBaseMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 base_money() const;
  inline void set_base_money(::google::protobuf::int32 value);

  // repeated .proto.login.tagPlayers players = 5;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 5;
  inline const ::proto::login::tagPlayers& players(int index) const;
  inline ::proto::login::tagPlayers* mutable_players(int index);
  inline ::proto::login::tagPlayers* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >*
      mutable_players();

  // optional int32 roomGolden = 6;
  inline bool has_roomgolden() const;
  inline void clear_roomgolden();
  static const int kRoomGoldenFieldNumber = 6;
  inline ::google::protobuf::int32 roomgolden() const;
  inline void set_roomgolden(::google::protobuf::int32 value);

  // optional int32 cardPoolNums = 7;
  inline bool has_cardpoolnums() const;
  inline void clear_cardpoolnums();
  static const int kCardPoolNumsFieldNumber = 7;
  inline ::google::protobuf::int32 cardpoolnums() const;
  inline void set_cardpoolnums(::google::protobuf::int32 value);

  // repeated int32 TouZiInfo = 8;
  inline int touziinfo_size() const;
  inline void clear_touziinfo();
  static const int kTouZiInfoFieldNumber = 8;
  inline ::google::protobuf::int32 touziinfo(int index) const;
  inline void set_touziinfo(int index, ::google::protobuf::int32 value);
  inline void add_touziinfo(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      touziinfo() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_touziinfo();

  // optional int32 GCrdFrmLstNum = 9;
  inline bool has_gcrdfrmlstnum() const;
  inline void clear_gcrdfrmlstnum();
  static const int kGCrdFrmLstNumFieldNumber = 9;
  inline ::google::protobuf::int32 gcrdfrmlstnum() const;
  inline void set_gcrdfrmlstnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckTableInfo)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_stand_money();
  inline void clear_has_stand_money();
  inline void set_has_base_money();
  inline void clear_has_base_money();
  inline void set_has_roomgolden();
  inline void clear_has_roomgolden();
  inline void set_has_cardpoolnums();
  inline void clear_has_cardpoolnums();
  inline void set_has_gcrdfrmlstnum();
  inline void clear_has_gcrdfrmlstnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 stand_money_;
  ::google::protobuf::int32 base_money_;
  ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers > players_;
  ::google::protobuf::int32 roomgolden_;
  ::google::protobuf::int32 cardpoolnums_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > touziinfo_;
  ::google::protobuf::int32 gcrdfrmlstnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckTableInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckLogoutBc : public ::google::protobuf::Message {
 public:
  AckLogoutBc();
  virtual ~AckLogoutBc();

  AckLogoutBc(const AckLogoutBc& from);

  inline AckLogoutBc& operator=(const AckLogoutBc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLogoutBc& default_instance();

  void Swap(AckLogoutBc* other);

  // implements Message ----------------------------------------------

  AckLogoutBc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLogoutBc& from);
  void MergeFrom(const AckLogoutBc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckLogoutBc)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckLogoutBc* default_instance_;
};
// -------------------------------------------------------------------

class AckUpTableSuccess : public ::google::protobuf::Message {
 public:
  AckUpTableSuccess();
  virtual ~AckUpTableSuccess();

  AckUpTableSuccess(const AckUpTableSuccess& from);

  inline AckUpTableSuccess& operator=(const AckUpTableSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpTableSuccess& default_instance();

  void Swap(AckUpTableSuccess* other);

  // implements Message ----------------------------------------------

  AckUpTableSuccess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpTableSuccess& from);
  void MergeFrom(const AckUpTableSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 seatid = 2;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 2;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 ready = 3;
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 3;
  inline ::google::protobuf::int32 ready() const;
  inline void set_ready(::google::protobuf::int32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional string avatar = 6;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 6;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // optional int32 money = 7;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 7;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 coin = 8;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 8;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // optional int32 exp = 9;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 9;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 pcount = 10;
  inline bool has_pcount() const;
  inline void clear_pcount();
  static const int kPcountFieldNumber = 10;
  inline ::google::protobuf::int32 pcount() const;
  inline void set_pcount(::google::protobuf::int32 value);

  // optional int32 vlevel = 11;
  inline bool has_vlevel() const;
  inline void clear_vlevel();
  static const int kVlevelFieldNumber = 11;
  inline ::google::protobuf::int32 vlevel() const;
  inline void set_vlevel(::google::protobuf::int32 value);

  // optional string ps = 12;
  inline bool has_ps() const;
  inline void clear_ps();
  static const int kPsFieldNumber = 12;
  inline const ::std::string& ps() const;
  inline void set_ps(const ::std::string& value);
  inline void set_ps(const char* value);
  inline void set_ps(const char* value, size_t size);
  inline ::std::string* mutable_ps();
  inline ::std::string* release_ps();
  inline void set_allocated_ps(::std::string* ps);

  // @@protoc_insertion_point(class_scope:proto.login.AckUpTableSuccess)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_ready();
  inline void clear_has_ready();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_pcount();
  inline void clear_has_pcount();
  inline void set_has_vlevel();
  inline void clear_has_vlevel();
  inline void set_has_ps();
  inline void clear_has_ps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 seatid_;
  ::std::string* name_;
  ::google::protobuf::int32 ready_;
  ::google::protobuf::int32 sex_;
  ::std::string* avatar_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 pcount_;
  ::std::string* ps_;
  ::google::protobuf::int32 vlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckUpTableSuccess* default_instance_;
};
// -------------------------------------------------------------------

class AckUpTableErrorUc : public ::google::protobuf::Message {
 public:
  AckUpTableErrorUc();
  virtual ~AckUpTableErrorUc();

  AckUpTableErrorUc(const AckUpTableErrorUc& from);

  inline AckUpTableErrorUc& operator=(const AckUpTableErrorUc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpTableErrorUc& default_instance();

  void Swap(AckUpTableErrorUc* other);

  // implements Message ----------------------------------------------

  AckUpTableErrorUc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpTableErrorUc& from);
  void MergeFrom(const AckUpTableErrorUc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 code = 3;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 3;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckUpTableErrorUc)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckUpTableErrorUc* default_instance_;
};
// -------------------------------------------------------------------

class AckAheadDownTable : public ::google::protobuf::Message {
 public:
  AckAheadDownTable();
  virtual ~AckAheadDownTable();

  AckAheadDownTable(const AckAheadDownTable& from);

  inline AckAheadDownTable& operator=(const AckAheadDownTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckAheadDownTable& default_instance();

  void Swap(AckAheadDownTable* other);

  // implements Message ----------------------------------------------

  AckAheadDownTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckAheadDownTable& from);
  void MergeFrom(const AckAheadDownTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 seatid = 2;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 2;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 down_tag = 3;
  inline bool has_down_tag() const;
  inline void clear_down_tag();
  static const int kDownTagFieldNumber = 3;
  inline ::google::protobuf::int32 down_tag() const;
  inline void set_down_tag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckAheadDownTable)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_down_tag();
  inline void clear_has_down_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 down_tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckAheadDownTable* default_instance_;
};
// -------------------------------------------------------------------

class AckDownTableSuccess : public ::google::protobuf::Message {
 public:
  AckDownTableSuccess();
  virtual ~AckDownTableSuccess();

  AckDownTableSuccess(const AckDownTableSuccess& from);

  inline AckDownTableSuccess& operator=(const AckDownTableSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckDownTableSuccess& default_instance();

  void Swap(AckDownTableSuccess* other);

  // implements Message ----------------------------------------------

  AckDownTableSuccess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckDownTableSuccess& from);
  void MergeFrom(const AckDownTableSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 seatid = 2;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 2;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckDownTableSuccess)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckDownTableSuccess* default_instance_;
};
// -------------------------------------------------------------------

class AckUpTableInfoReq : public ::google::protobuf::Message {
 public:
  AckUpTableInfoReq();
  virtual ~AckUpTableInfoReq();

  AckUpTableInfoReq(const AckUpTableInfoReq& from);

  inline AckUpTableInfoReq& operator=(const AckUpTableInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpTableInfoReq& default_instance();

  void Swap(AckUpTableInfoReq* other);

  // implements Message ----------------------------------------------

  AckUpTableInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpTableInfoReq& from);
  void MergeFrom(const AckUpTableInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 start_index = 1;
  inline bool has_start_index() const;
  inline void clear_start_index();
  static const int kStartIndexFieldNumber = 1;
  inline ::google::protobuf::int32 start_index() const;
  inline void set_start_index(::google::protobuf::int32 value);

  // optional int32 end_index = 2;
  inline bool has_end_index() const;
  inline void clear_end_index();
  static const int kEndIndexFieldNumber = 2;
  inline ::google::protobuf::int32 end_index() const;
  inline void set_end_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckUpTableInfoReq)
 private:
  inline void set_has_start_index();
  inline void clear_has_start_index();
  inline void set_has_end_index();
  inline void clear_has_end_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 start_index_;
  ::google::protobuf::int32 end_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckUpTableInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class AckUpTableInfo_UC : public ::google::protobuf::Message {
 public:
  AckUpTableInfo_UC();
  virtual ~AckUpTableInfo_UC();

  AckUpTableInfo_UC(const AckUpTableInfo_UC& from);

  inline AckUpTableInfo_UC& operator=(const AckUpTableInfo_UC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpTableInfo_UC& default_instance();

  void Swap(AckUpTableInfo_UC* other);

  // implements Message ----------------------------------------------

  AckUpTableInfo_UC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpTableInfo_UC& from);
  void MergeFrom(const AckUpTableInfo_UC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.login.tagPlayers players = 1;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 1;
  inline const ::proto::login::tagPlayers& players(int index) const;
  inline ::proto::login::tagPlayers* mutable_players(int index);
  inline ::proto::login::tagPlayers* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >*
      mutable_players();

  // optional int32 rank = 2;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 2;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // optional int32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // optional int32 down_tag = 4;
  inline bool has_down_tag() const;
  inline void clear_down_tag();
  static const int kDownTagFieldNumber = 4;
  inline ::google::protobuf::int32 down_tag() const;
  inline void set_down_tag(::google::protobuf::int32 value);

  // optional int32 limit_money = 5;
  inline bool has_limit_money() const;
  inline void clear_limit_money();
  static const int kLimitMoneyFieldNumber = 5;
  inline ::google::protobuf::int32 limit_money() const;
  inline void set_limit_money(::google::protobuf::int32 value);

  // optional int32 stand_money = 6;
  inline bool has_stand_money() const;
  inline void clear_stand_money();
  static const int kStandMoneyFieldNumber = 6;
  inline ::google::protobuf::int32 stand_money() const;
  inline void set_stand_money(::google::protobuf::int32 value);

  // optional int32 base_money = 7;
  inline bool has_base_money() const;
  inline void clear_base_money();
  static const int kBaseMoneyFieldNumber = 7;
  inline ::google::protobuf::int32 base_money() const;
  inline void set_base_money(::google::protobuf::int32 value);

  // optional int32 left_len = 8;
  inline bool has_left_len() const;
  inline void clear_left_len();
  static const int kLeftLenFieldNumber = 8;
  inline ::google::protobuf::int32 left_len() const;
  inline void set_left_len(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckUpTableInfo_UC)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_down_tag();
  inline void clear_has_down_tag();
  inline void set_has_limit_money();
  inline void clear_has_limit_money();
  inline void set_has_stand_money();
  inline void clear_has_stand_money();
  inline void set_has_base_money();
  inline void clear_has_base_money();
  inline void set_has_left_len();
  inline void clear_has_left_len();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers > players_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 number_;
  ::google::protobuf::int32 down_tag_;
  ::google::protobuf::int32 limit_money_;
  ::google::protobuf::int32 stand_money_;
  ::google::protobuf::int32 base_money_;
  ::google::protobuf::int32 left_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckUpTableInfo_UC* default_instance_;
};
// -------------------------------------------------------------------

class AckUpTableInfo_BC : public ::google::protobuf::Message {
 public:
  AckUpTableInfo_BC();
  virtual ~AckUpTableInfo_BC();

  AckUpTableInfo_BC(const AckUpTableInfo_BC& from);

  inline AckUpTableInfo_BC& operator=(const AckUpTableInfo_BC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpTableInfo_BC& default_instance();

  void Swap(AckUpTableInfo_BC* other);

  // implements Message ----------------------------------------------

  AckUpTableInfo_BC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpTableInfo_BC& from);
  void MergeFrom(const AckUpTableInfo_BC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.login.tagPlayers players = 1;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 1;
  inline const ::proto::login::tagPlayers& players(int index) const;
  inline ::proto::login::tagPlayers* mutable_players(int index);
  inline ::proto::login::tagPlayers* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:proto.login.AckUpTableInfo_BC)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers > players_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckUpTableInfo_BC* default_instance_;
};
// -------------------------------------------------------------------

class AckAllLookOnUserResp : public ::google::protobuf::Message {
 public:
  AckAllLookOnUserResp();
  virtual ~AckAllLookOnUserResp();

  AckAllLookOnUserResp(const AckAllLookOnUserResp& from);

  inline AckAllLookOnUserResp& operator=(const AckAllLookOnUserResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckAllLookOnUserResp& default_instance();

  void Swap(AckAllLookOnUserResp* other);

  // implements Message ----------------------------------------------

  AckAllLookOnUserResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckAllLookOnUserResp& from);
  void MergeFrom(const AckAllLookOnUserResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.login.tagPlayers players = 1;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 1;
  inline const ::proto::login::tagPlayers& players(int index) const;
  inline ::proto::login::tagPlayers* mutable_players(int index);
  inline ::proto::login::tagPlayers* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >*
      mutable_players();

  // optional int32 left_len = 2;
  inline bool has_left_len() const;
  inline void clear_left_len();
  static const int kLeftLenFieldNumber = 2;
  inline ::google::protobuf::int32 left_len() const;
  inline void set_left_len(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckAllLookOnUserResp)
 private:
  inline void set_has_left_len();
  inline void clear_has_left_len();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers > players_;
  ::google::protobuf::int32 left_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckAllLookOnUserResp* default_instance_;
};
// -------------------------------------------------------------------

class AckHeatBeat : public ::google::protobuf::Message {
 public:
  AckHeatBeat();
  virtual ~AckHeatBeat();

  AckHeatBeat(const AckHeatBeat& from);

  inline AckHeatBeat& operator=(const AckHeatBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckHeatBeat& default_instance();

  void Swap(AckHeatBeat* other);

  // implements Message ----------------------------------------------

  AckHeatBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckHeatBeat& from);
  void MergeFrom(const AckHeatBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckHeatBeat)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckHeatBeat* default_instance_;
};
// -------------------------------------------------------------------

class AckPrereadyBC : public ::google::protobuf::Message {
 public:
  AckPrereadyBC();
  virtual ~AckPrereadyBC();

  AckPrereadyBC(const AckPrereadyBC& from);

  inline AckPrereadyBC& operator=(const AckPrereadyBC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPrereadyBC& default_instance();

  void Swap(AckPrereadyBC* other);

  // implements Message ----------------------------------------------

  AckPrereadyBC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPrereadyBC& from);
  void MergeFrom(const AckPrereadyBC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 roomid = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  inline ::google::protobuf::int32 roomid() const;
  inline void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckPrereadyBC)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckPrereadyBC* default_instance_;
};
// -------------------------------------------------------------------

class AckEmotionBC : public ::google::protobuf::Message {
 public:
  AckEmotionBC();
  virtual ~AckEmotionBC();

  AckEmotionBC(const AckEmotionBC& from);

  inline AckEmotionBC& operator=(const AckEmotionBC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckEmotionBC& default_instance();

  void Swap(AckEmotionBC* other);

  // implements Message ----------------------------------------------

  AckEmotionBC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckEmotionBC& from);
  void MergeFrom(const AckEmotionBC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional int32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 target_seatid = 3;
  inline bool has_target_seatid() const;
  inline void clear_target_seatid();
  static const int kTargetSeatidFieldNumber = 3;
  inline ::google::protobuf::int32 target_seatid() const;
  inline void set_target_seatid(::google::protobuf::int32 value);

  // optional int32 target_seat_num = 4;
  inline bool has_target_seat_num() const;
  inline void clear_target_seat_num();
  static const int kTargetSeatNumFieldNumber = 4;
  inline ::google::protobuf::int32 target_seat_num() const;
  inline void set_target_seat_num(::google::protobuf::int32 value);

  // optional int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.login.AckEmotionBC)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_target_seatid();
  inline void clear_has_target_seatid();
  inline void set_has_target_seat_num();
  inline void clear_has_target_seat_num();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 target_seatid_;
  ::google::protobuf::int32 target_seat_num_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckEmotionBC* default_instance_;
};
// -------------------------------------------------------------------

class AckChatBC : public ::google::protobuf::Message {
 public:
  AckChatBC();
  virtual ~AckChatBC();

  AckChatBC(const AckChatBC& from);

  inline AckChatBC& operator=(const AckChatBC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckChatBC& default_instance();

  void Swap(AckChatBC* other);

  // implements Message ----------------------------------------------

  AckChatBC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckChatBC& from);
  void MergeFrom(const AckChatBC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  inline bool has_seatid() const;
  inline void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  inline ::google::protobuf::int32 seatid() const;
  inline void set_seatid(::google::protobuf::int32 value);

  // optional string charmsg = 2;
  inline bool has_charmsg() const;
  inline void clear_charmsg();
  static const int kCharmsgFieldNumber = 2;
  inline const ::std::string& charmsg() const;
  inline void set_charmsg(const ::std::string& value);
  inline void set_charmsg(const char* value);
  inline void set_charmsg(const char* value, size_t size);
  inline ::std::string* mutable_charmsg();
  inline ::std::string* release_charmsg();
  inline void set_allocated_charmsg(::std::string* charmsg);

  // @@protoc_insertion_point(class_scope:proto.login.AckChatBC)
 private:
  inline void set_has_seatid();
  inline void clear_has_seatid();
  inline void set_has_charmsg();
  inline void clear_has_charmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* charmsg_;
  ::google::protobuf::int32 seatid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_loginproto_2eproto();
  friend void protobuf_AssignDesc_loginproto_2eproto();
  friend void protobuf_ShutdownFile_loginproto_2eproto();

  void InitAsDefaultInstance();
  static AckChatBC* default_instance_;
};
// ===================================================================


// ===================================================================

// ReqLogin

// required int32 uid = 1;
inline bool ReqLogin::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLogin::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLogin::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLogin::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ReqLogin::uid() const {
  return uid_;
}
inline void ReqLogin::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional string skey = 4;
inline bool ReqLogin::has_skey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLogin::set_has_skey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLogin::clear_has_skey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLogin::clear_skey() {
  if (skey_ != &::google::protobuf::internal::kEmptyString) {
    skey_->clear();
  }
  clear_has_skey();
}
inline const ::std::string& ReqLogin::skey() const {
  return *skey_;
}
inline void ReqLogin::set_skey(const ::std::string& value) {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  skey_->assign(value);
}
inline void ReqLogin::set_skey(const char* value) {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  skey_->assign(value);
}
inline void ReqLogin::set_skey(const char* value, size_t size) {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  skey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_skey() {
  set_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    skey_ = new ::std::string;
  }
  return skey_;
}
inline ::std::string* ReqLogin::release_skey() {
  clear_has_skey();
  if (skey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = skey_;
    skey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogin::set_allocated_skey(::std::string* skey) {
  if (skey_ != &::google::protobuf::internal::kEmptyString) {
    delete skey_;
  }
  if (skey) {
    set_has_skey();
    skey_ = skey;
  } else {
    clear_has_skey();
    skey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 roomid = 5;
inline bool ReqLogin::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqLogin::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqLogin::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqLogin::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 ReqLogin::roomid() const {
  return roomid_;
}
inline void ReqLogin::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional string deviceId = 6;
inline bool ReqLogin::has_deviceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqLogin::set_has_deviceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqLogin::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqLogin::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& ReqLogin::deviceid() const {
  return *deviceid_;
}
inline void ReqLogin::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void ReqLogin::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void ReqLogin::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* ReqLogin::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogin::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 base_money = 7;
inline bool ReqLogin::has_base_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqLogin::set_has_base_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqLogin::clear_has_base_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqLogin::clear_base_money() {
  base_money_ = 0;
  clear_has_base_money();
}
inline ::google::protobuf::int32 ReqLogin::base_money() const {
  return base_money_;
}
inline void ReqLogin::set_base_money(::google::protobuf::int32 value) {
  set_has_base_money();
  base_money_ = value;
}

// optional int32 stand_money = 8;
inline bool ReqLogin::has_stand_money() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqLogin::set_has_stand_money() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqLogin::clear_has_stand_money() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqLogin::clear_stand_money() {
  stand_money_ = 0;
  clear_has_stand_money();
}
inline ::google::protobuf::int32 ReqLogin::stand_money() const {
  return stand_money_;
}
inline void ReqLogin::set_stand_money(::google::protobuf::int32 value) {
  set_has_stand_money();
  stand_money_ = value;
}

// -------------------------------------------------------------------

// ReqLogout

// required int32 uid = 1;
inline bool ReqLogout::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLogout::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLogout::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLogout::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ReqLogout::uid() const {
  return uid_;
}
inline void ReqLogout::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// ReqReady

// required int32 uid = 1;
inline bool ReqReady::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqReady::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqReady::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqReady::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ReqReady::uid() const {
  return uid_;
}
inline void ReqReady::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 seatid = 2;
inline bool ReqReady::has_seatid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqReady::set_has_seatid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqReady::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqReady::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 ReqReady::seatid() const {
  return seatid_;
}
inline void ReqReady::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// -------------------------------------------------------------------

// ReqTableAction

// required int32 uid = 1;
inline bool ReqTableAction::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqTableAction::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqTableAction::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqTableAction::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ReqTableAction::uid() const {
  return uid_;
}
inline void ReqTableAction::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 roomid = 2;
inline bool ReqTableAction::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqTableAction::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqTableAction::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqTableAction::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 ReqTableAction::roomid() const {
  return roomid_;
}
inline void ReqTableAction::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// -------------------------------------------------------------------

// ReqHeatBeat

// required int32 state = 1;
inline bool ReqHeatBeat::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqHeatBeat::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqHeatBeat::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqHeatBeat::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 ReqHeatBeat::state() const {
  return state_;
}
inline void ReqHeatBeat::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// AllLookOnUserReq

// required int32 start_index = 1;
inline bool AllLookOnUserReq::has_start_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllLookOnUserReq::set_has_start_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllLookOnUserReq::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllLookOnUserReq::clear_start_index() {
  start_index_ = 0;
  clear_has_start_index();
}
inline ::google::protobuf::int32 AllLookOnUserReq::start_index() const {
  return start_index_;
}
inline void AllLookOnUserReq::set_start_index(::google::protobuf::int32 value) {
  set_has_start_index();
  start_index_ = value;
}

// optional int32 end_index = 2;
inline bool AllLookOnUserReq::has_end_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllLookOnUserReq::set_has_end_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllLookOnUserReq::clear_has_end_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllLookOnUserReq::clear_end_index() {
  end_index_ = 0;
  clear_has_end_index();
}
inline ::google::protobuf::int32 AllLookOnUserReq::end_index() const {
  return end_index_;
}
inline void AllLookOnUserReq::set_end_index(::google::protobuf::int32 value) {
  set_has_end_index();
  end_index_ = value;
}

// -------------------------------------------------------------------

// ReqEmotion

// required int32 seatid = 1;
inline bool ReqEmotion::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqEmotion::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqEmotion::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqEmotion::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 ReqEmotion::seatid() const {
  return seatid_;
}
inline void ReqEmotion::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 target_seatid = 2;
inline bool ReqEmotion::has_target_seatid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqEmotion::set_has_target_seatid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqEmotion::clear_has_target_seatid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqEmotion::clear_target_seatid() {
  target_seatid_ = 0;
  clear_has_target_seatid();
}
inline ::google::protobuf::int32 ReqEmotion::target_seatid() const {
  return target_seatid_;
}
inline void ReqEmotion::set_target_seatid(::google::protobuf::int32 value) {
  set_has_target_seatid();
  target_seatid_ = value;
}

// optional int32 target_seat_num = 3;
inline bool ReqEmotion::has_target_seat_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqEmotion::set_has_target_seat_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqEmotion::clear_has_target_seat_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqEmotion::clear_target_seat_num() {
  target_seat_num_ = 0;
  clear_has_target_seat_num();
}
inline ::google::protobuf::int32 ReqEmotion::target_seat_num() const {
  return target_seat_num_;
}
inline void ReqEmotion::set_target_seat_num(::google::protobuf::int32 value) {
  set_has_target_seat_num();
  target_seat_num_ = value;
}

// optional int32 type = 4;
inline bool ReqEmotion::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqEmotion::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqEmotion::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqEmotion::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ReqEmotion::type() const {
  return type_;
}
inline void ReqEmotion::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// AckLoginSuccessUc

// required int32 seatid = 1;
inline bool AckLoginSuccessUc::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLoginSuccessUc::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLoginSuccessUc::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLoginSuccessUc::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::seatid() const {
  return seatid_;
}
inline void AckLoginSuccessUc::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional string avatar = 2;
inline bool AckLoginSuccessUc::has_avatar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckLoginSuccessUc::set_has_avatar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckLoginSuccessUc::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckLoginSuccessUc::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& AckLoginSuccessUc::avatar() const {
  return *avatar_;
}
inline void AckLoginSuccessUc::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckLoginSuccessUc::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckLoginSuccessUc::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckLoginSuccessUc::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* AckLoginSuccessUc::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckLoginSuccessUc::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 coin = 3;
inline bool AckLoginSuccessUc::has_coin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckLoginSuccessUc::set_has_coin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckLoginSuccessUc::clear_has_coin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckLoginSuccessUc::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::coin() const {
  return coin_;
}
inline void AckLoginSuccessUc::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional int32 exp = 4;
inline bool AckLoginSuccessUc::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckLoginSuccessUc::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckLoginSuccessUc::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckLoginSuccessUc::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::exp() const {
  return exp_;
}
inline void AckLoginSuccessUc::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 money = 5;
inline bool AckLoginSuccessUc::has_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckLoginSuccessUc::set_has_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckLoginSuccessUc::clear_has_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckLoginSuccessUc::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::money() const {
  return money_;
}
inline void AckLoginSuccessUc::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional string name = 6;
inline bool AckLoginSuccessUc::has_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckLoginSuccessUc::set_has_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckLoginSuccessUc::clear_has_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckLoginSuccessUc::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AckLoginSuccessUc::name() const {
  return *name_;
}
inline void AckLoginSuccessUc::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckLoginSuccessUc::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckLoginSuccessUc::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckLoginSuccessUc::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AckLoginSuccessUc::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckLoginSuccessUc::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ready = 7;
inline bool AckLoginSuccessUc::has_ready() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckLoginSuccessUc::set_has_ready() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckLoginSuccessUc::clear_has_ready() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckLoginSuccessUc::clear_ready() {
  ready_ = 0;
  clear_has_ready();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::ready() const {
  return ready_;
}
inline void AckLoginSuccessUc::set_ready(::google::protobuf::int32 value) {
  set_has_ready();
  ready_ = value;
}

// optional int32 rmb = 8;
inline bool AckLoginSuccessUc::has_rmb() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckLoginSuccessUc::set_has_rmb() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckLoginSuccessUc::clear_has_rmb() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckLoginSuccessUc::clear_rmb() {
  rmb_ = 0;
  clear_has_rmb();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::rmb() const {
  return rmb_;
}
inline void AckLoginSuccessUc::set_rmb(::google::protobuf::int32 value) {
  set_has_rmb();
  rmb_ = value;
}

// optional int32 see = 9;
inline bool AckLoginSuccessUc::has_see() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckLoginSuccessUc::set_has_see() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckLoginSuccessUc::clear_has_see() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckLoginSuccessUc::clear_see() {
  see_ = 0;
  clear_has_see();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::see() const {
  return see_;
}
inline void AckLoginSuccessUc::set_see(::google::protobuf::int32 value) {
  set_has_see();
  see_ = value;
}

// optional int32 sex = 10;
inline bool AckLoginSuccessUc::has_sex() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AckLoginSuccessUc::set_has_sex() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AckLoginSuccessUc::clear_has_sex() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AckLoginSuccessUc::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::sex() const {
  return sex_;
}
inline void AckLoginSuccessUc::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional int32 total_board = 11;
inline bool AckLoginSuccessUc::has_total_board() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AckLoginSuccessUc::set_has_total_board() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AckLoginSuccessUc::clear_has_total_board() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AckLoginSuccessUc::clear_total_board() {
  total_board_ = 0;
  clear_has_total_board();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::total_board() const {
  return total_board_;
}
inline void AckLoginSuccessUc::set_total_board(::google::protobuf::int32 value) {
  set_has_total_board();
  total_board_ = value;
}

// optional int32 total_win = 12;
inline bool AckLoginSuccessUc::has_total_win() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AckLoginSuccessUc::set_has_total_win() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AckLoginSuccessUc::clear_has_total_win() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AckLoginSuccessUc::clear_total_win() {
  total_win_ = 0;
  clear_has_total_win();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::total_win() const {
  return total_win_;
}
inline void AckLoginSuccessUc::set_total_win(::google::protobuf::int32 value) {
  set_has_total_win();
  total_win_ = value;
}

// optional int32 uid = 13;
inline bool AckLoginSuccessUc::has_uid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AckLoginSuccessUc::set_has_uid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AckLoginSuccessUc::clear_has_uid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AckLoginSuccessUc::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::uid() const {
  return uid_;
}
inline void AckLoginSuccessUc::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 vlevel = 14;
inline bool AckLoginSuccessUc::has_vlevel() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AckLoginSuccessUc::set_has_vlevel() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AckLoginSuccessUc::clear_has_vlevel() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AckLoginSuccessUc::clear_vlevel() {
  vlevel_ = 0;
  clear_has_vlevel();
}
inline ::google::protobuf::int32 AckLoginSuccessUc::vlevel() const {
  return vlevel_;
}
inline void AckLoginSuccessUc::set_vlevel(::google::protobuf::int32 value) {
  set_has_vlevel();
  vlevel_ = value;
}

// -------------------------------------------------------------------

// AckLoginSuccessBc

// required int32 seatid = 1;
inline bool AckLoginSuccessBc::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLoginSuccessBc::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLoginSuccessBc::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLoginSuccessBc::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckLoginSuccessBc::seatid() const {
  return seatid_;
}
inline void AckLoginSuccessBc::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 uid = 2;
inline bool AckLoginSuccessBc::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckLoginSuccessBc::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckLoginSuccessBc::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckLoginSuccessBc::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckLoginSuccessBc::uid() const {
  return uid_;
}
inline void AckLoginSuccessBc::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 money = 3;
inline bool AckLoginSuccessBc::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckLoginSuccessBc::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckLoginSuccessBc::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckLoginSuccessBc::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckLoginSuccessBc::money() const {
  return money_;
}
inline void AckLoginSuccessBc::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional string name = 4;
inline bool AckLoginSuccessBc::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckLoginSuccessBc::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckLoginSuccessBc::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckLoginSuccessBc::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AckLoginSuccessBc::name() const {
  return *name_;
}
inline void AckLoginSuccessBc::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckLoginSuccessBc::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckLoginSuccessBc::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckLoginSuccessBc::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AckLoginSuccessBc::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckLoginSuccessBc::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string avatar = 5;
inline bool AckLoginSuccessBc::has_avatar() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckLoginSuccessBc::set_has_avatar() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckLoginSuccessBc::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckLoginSuccessBc::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& AckLoginSuccessBc::avatar() const {
  return *avatar_;
}
inline void AckLoginSuccessBc::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckLoginSuccessBc::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckLoginSuccessBc::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckLoginSuccessBc::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* AckLoginSuccessBc::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckLoginSuccessBc::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sex = 6;
inline bool AckLoginSuccessBc::has_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckLoginSuccessBc::set_has_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckLoginSuccessBc::clear_has_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckLoginSuccessBc::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 AckLoginSuccessBc::sex() const {
  return sex_;
}
inline void AckLoginSuccessBc::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// AckLoginError

// required int32 uid = 1;
inline bool AckLoginError::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLoginError::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLoginError::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLoginError::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckLoginError::uid() const {
  return uid_;
}
inline void AckLoginError::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 code = 2;
inline bool AckLoginError::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckLoginError::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckLoginError::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckLoginError::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 AckLoginError::code() const {
  return code_;
}
inline void AckLoginError::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// AckGPS

// optional int32 uid = 1;
inline bool AckGPS::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckGPS::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckGPS::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckGPS::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckGPS::uid() const {
  return uid_;
}
inline void AckGPS::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional double latitude = 2;
inline bool AckGPS::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckGPS::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckGPS::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckGPS::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double AckGPS::latitude() const {
  return latitude_;
}
inline void AckGPS::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// optional double longitude = 3;
inline bool AckGPS::has_longitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckGPS::set_has_longitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckGPS::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckGPS::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double AckGPS::longitude() const {
  return longitude_;
}
inline void AckGPS::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// optional string city = 4;
inline bool AckGPS::has_city() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckGPS::set_has_city() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckGPS::clear_has_city() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckGPS::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& AckGPS::city() const {
  return *city_;
}
inline void AckGPS::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void AckGPS::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void AckGPS::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckGPS::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* AckGPS::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckGPS::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// tagPlayers

// required int32 uid = 1;
inline bool tagPlayers::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tagPlayers::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tagPlayers::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tagPlayers::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 tagPlayers::uid() const {
  return uid_;
}
inline void tagPlayers::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 seatid = 2;
inline bool tagPlayers::has_seatid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tagPlayers::set_has_seatid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tagPlayers::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tagPlayers::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 tagPlayers::seatid() const {
  return seatid_;
}
inline void tagPlayers::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 ready = 3;
inline bool tagPlayers::has_ready() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tagPlayers::set_has_ready() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tagPlayers::clear_has_ready() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tagPlayers::clear_ready() {
  ready_ = 0;
  clear_has_ready();
}
inline ::google::protobuf::int32 tagPlayers::ready() const {
  return ready_;
}
inline void tagPlayers::set_ready(::google::protobuf::int32 value) {
  set_has_ready();
  ready_ = value;
}

// optional int32 money = 4;
inline bool tagPlayers::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void tagPlayers::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void tagPlayers::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void tagPlayers::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 tagPlayers::money() const {
  return money_;
}
inline void tagPlayers::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional string name = 5;
inline bool tagPlayers::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void tagPlayers::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void tagPlayers::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void tagPlayers::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& tagPlayers::name() const {
  return *name_;
}
inline void tagPlayers::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void tagPlayers::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void tagPlayers::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tagPlayers::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* tagPlayers::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tagPlayers::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sex = 6;
inline bool tagPlayers::has_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void tagPlayers::set_has_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void tagPlayers::clear_has_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void tagPlayers::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 tagPlayers::sex() const {
  return sex_;
}
inline void tagPlayers::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional string avatar = 7;
inline bool tagPlayers::has_avatar() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void tagPlayers::set_has_avatar() {
  _has_bits_[0] |= 0x00000040u;
}
inline void tagPlayers::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void tagPlayers::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& tagPlayers::avatar() const {
  return *avatar_;
}
inline void tagPlayers::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void tagPlayers::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void tagPlayers::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tagPlayers::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* tagPlayers::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tagPlayers::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.login.AckGPS GPS = 8;
inline bool tagPlayers::has_gps() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void tagPlayers::set_has_gps() {
  _has_bits_[0] |= 0x00000080u;
}
inline void tagPlayers::clear_has_gps() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void tagPlayers::clear_gps() {
  if (gps_ != NULL) gps_->::proto::login::AckGPS::Clear();
  clear_has_gps();
}
inline const ::proto::login::AckGPS& tagPlayers::gps() const {
  return gps_ != NULL ? *gps_ : *default_instance_->gps_;
}
inline ::proto::login::AckGPS* tagPlayers::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) gps_ = new ::proto::login::AckGPS;
  return gps_;
}
inline ::proto::login::AckGPS* tagPlayers::release_gps() {
  clear_has_gps();
  ::proto::login::AckGPS* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void tagPlayers::set_allocated_gps(::proto::login::AckGPS* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
}

// -------------------------------------------------------------------

// AckTableInfo

// required int32 seatid = 1;
inline bool AckTableInfo::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckTableInfo::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckTableInfo::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckTableInfo::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckTableInfo::seatid() const {
  return seatid_;
}
inline void AckTableInfo::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 state = 2;
inline bool AckTableInfo::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckTableInfo::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckTableInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckTableInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 AckTableInfo::state() const {
  return state_;
}
inline void AckTableInfo::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional int32 stand_money = 3;
inline bool AckTableInfo::has_stand_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckTableInfo::set_has_stand_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckTableInfo::clear_has_stand_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckTableInfo::clear_stand_money() {
  stand_money_ = 0;
  clear_has_stand_money();
}
inline ::google::protobuf::int32 AckTableInfo::stand_money() const {
  return stand_money_;
}
inline void AckTableInfo::set_stand_money(::google::protobuf::int32 value) {
  set_has_stand_money();
  stand_money_ = value;
}

// optional int32 base_money = 4;
inline bool AckTableInfo::has_base_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckTableInfo::set_has_base_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckTableInfo::clear_has_base_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckTableInfo::clear_base_money() {
  base_money_ = 0;
  clear_has_base_money();
}
inline ::google::protobuf::int32 AckTableInfo::base_money() const {
  return base_money_;
}
inline void AckTableInfo::set_base_money(::google::protobuf::int32 value) {
  set_has_base_money();
  base_money_ = value;
}

// repeated .proto.login.tagPlayers players = 5;
inline int AckTableInfo::players_size() const {
  return players_.size();
}
inline void AckTableInfo::clear_players() {
  players_.Clear();
}
inline const ::proto::login::tagPlayers& AckTableInfo::players(int index) const {
  return players_.Get(index);
}
inline ::proto::login::tagPlayers* AckTableInfo::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::proto::login::tagPlayers* AckTableInfo::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >&
AckTableInfo::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >*
AckTableInfo::mutable_players() {
  return &players_;
}

// optional int32 roomGolden = 6;
inline bool AckTableInfo::has_roomgolden() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckTableInfo::set_has_roomgolden() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckTableInfo::clear_has_roomgolden() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckTableInfo::clear_roomgolden() {
  roomgolden_ = 0;
  clear_has_roomgolden();
}
inline ::google::protobuf::int32 AckTableInfo::roomgolden() const {
  return roomgolden_;
}
inline void AckTableInfo::set_roomgolden(::google::protobuf::int32 value) {
  set_has_roomgolden();
  roomgolden_ = value;
}

// optional int32 cardPoolNums = 7;
inline bool AckTableInfo::has_cardpoolnums() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckTableInfo::set_has_cardpoolnums() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckTableInfo::clear_has_cardpoolnums() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckTableInfo::clear_cardpoolnums() {
  cardpoolnums_ = 0;
  clear_has_cardpoolnums();
}
inline ::google::protobuf::int32 AckTableInfo::cardpoolnums() const {
  return cardpoolnums_;
}
inline void AckTableInfo::set_cardpoolnums(::google::protobuf::int32 value) {
  set_has_cardpoolnums();
  cardpoolnums_ = value;
}

// repeated int32 TouZiInfo = 8;
inline int AckTableInfo::touziinfo_size() const {
  return touziinfo_.size();
}
inline void AckTableInfo::clear_touziinfo() {
  touziinfo_.Clear();
}
inline ::google::protobuf::int32 AckTableInfo::touziinfo(int index) const {
  return touziinfo_.Get(index);
}
inline void AckTableInfo::set_touziinfo(int index, ::google::protobuf::int32 value) {
  touziinfo_.Set(index, value);
}
inline void AckTableInfo::add_touziinfo(::google::protobuf::int32 value) {
  touziinfo_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AckTableInfo::touziinfo() const {
  return touziinfo_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AckTableInfo::mutable_touziinfo() {
  return &touziinfo_;
}

// optional int32 GCrdFrmLstNum = 9;
inline bool AckTableInfo::has_gcrdfrmlstnum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckTableInfo::set_has_gcrdfrmlstnum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckTableInfo::clear_has_gcrdfrmlstnum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckTableInfo::clear_gcrdfrmlstnum() {
  gcrdfrmlstnum_ = 0;
  clear_has_gcrdfrmlstnum();
}
inline ::google::protobuf::int32 AckTableInfo::gcrdfrmlstnum() const {
  return gcrdfrmlstnum_;
}
inline void AckTableInfo::set_gcrdfrmlstnum(::google::protobuf::int32 value) {
  set_has_gcrdfrmlstnum();
  gcrdfrmlstnum_ = value;
}

// -------------------------------------------------------------------

// AckLogoutBc

// required int32 seatid = 1;
inline bool AckLogoutBc::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLogoutBc::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLogoutBc::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLogoutBc::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckLogoutBc::seatid() const {
  return seatid_;
}
inline void AckLogoutBc::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 uid = 2;
inline bool AckLogoutBc::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckLogoutBc::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckLogoutBc::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckLogoutBc::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckLogoutBc::uid() const {
  return uid_;
}
inline void AckLogoutBc::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 type = 3;
inline bool AckLogoutBc::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckLogoutBc::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckLogoutBc::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckLogoutBc::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AckLogoutBc::type() const {
  return type_;
}
inline void AckLogoutBc::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// AckUpTableSuccess

// required int32 uid = 1;
inline bool AckUpTableSuccess::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUpTableSuccess::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUpTableSuccess::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUpTableSuccess::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckUpTableSuccess::uid() const {
  return uid_;
}
inline void AckUpTableSuccess::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 seatid = 2;
inline bool AckUpTableSuccess::has_seatid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUpTableSuccess::set_has_seatid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUpTableSuccess::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUpTableSuccess::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckUpTableSuccess::seatid() const {
  return seatid_;
}
inline void AckUpTableSuccess::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 ready = 3;
inline bool AckUpTableSuccess::has_ready() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckUpTableSuccess::set_has_ready() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckUpTableSuccess::clear_has_ready() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckUpTableSuccess::clear_ready() {
  ready_ = 0;
  clear_has_ready();
}
inline ::google::protobuf::int32 AckUpTableSuccess::ready() const {
  return ready_;
}
inline void AckUpTableSuccess::set_ready(::google::protobuf::int32 value) {
  set_has_ready();
  ready_ = value;
}

// optional string name = 4;
inline bool AckUpTableSuccess::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckUpTableSuccess::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckUpTableSuccess::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckUpTableSuccess::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AckUpTableSuccess::name() const {
  return *name_;
}
inline void AckUpTableSuccess::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckUpTableSuccess::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckUpTableSuccess::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckUpTableSuccess::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AckUpTableSuccess::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckUpTableSuccess::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 sex = 5;
inline bool AckUpTableSuccess::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckUpTableSuccess::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckUpTableSuccess::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckUpTableSuccess::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 AckUpTableSuccess::sex() const {
  return sex_;
}
inline void AckUpTableSuccess::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional string avatar = 6;
inline bool AckUpTableSuccess::has_avatar() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckUpTableSuccess::set_has_avatar() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckUpTableSuccess::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckUpTableSuccess::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& AckUpTableSuccess::avatar() const {
  return *avatar_;
}
inline void AckUpTableSuccess::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckUpTableSuccess::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void AckUpTableSuccess::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckUpTableSuccess::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* AckUpTableSuccess::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckUpTableSuccess::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 money = 7;
inline bool AckUpTableSuccess::has_money() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckUpTableSuccess::set_has_money() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckUpTableSuccess::clear_has_money() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckUpTableSuccess::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckUpTableSuccess::money() const {
  return money_;
}
inline void AckUpTableSuccess::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 coin = 8;
inline bool AckUpTableSuccess::has_coin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckUpTableSuccess::set_has_coin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckUpTableSuccess::clear_has_coin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckUpTableSuccess::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 AckUpTableSuccess::coin() const {
  return coin_;
}
inline void AckUpTableSuccess::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional int32 exp = 9;
inline bool AckUpTableSuccess::has_exp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckUpTableSuccess::set_has_exp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckUpTableSuccess::clear_has_exp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckUpTableSuccess::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 AckUpTableSuccess::exp() const {
  return exp_;
}
inline void AckUpTableSuccess::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 pcount = 10;
inline bool AckUpTableSuccess::has_pcount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AckUpTableSuccess::set_has_pcount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AckUpTableSuccess::clear_has_pcount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AckUpTableSuccess::clear_pcount() {
  pcount_ = 0;
  clear_has_pcount();
}
inline ::google::protobuf::int32 AckUpTableSuccess::pcount() const {
  return pcount_;
}
inline void AckUpTableSuccess::set_pcount(::google::protobuf::int32 value) {
  set_has_pcount();
  pcount_ = value;
}

// optional int32 vlevel = 11;
inline bool AckUpTableSuccess::has_vlevel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AckUpTableSuccess::set_has_vlevel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AckUpTableSuccess::clear_has_vlevel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AckUpTableSuccess::clear_vlevel() {
  vlevel_ = 0;
  clear_has_vlevel();
}
inline ::google::protobuf::int32 AckUpTableSuccess::vlevel() const {
  return vlevel_;
}
inline void AckUpTableSuccess::set_vlevel(::google::protobuf::int32 value) {
  set_has_vlevel();
  vlevel_ = value;
}

// optional string ps = 12;
inline bool AckUpTableSuccess::has_ps() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AckUpTableSuccess::set_has_ps() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AckUpTableSuccess::clear_has_ps() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AckUpTableSuccess::clear_ps() {
  if (ps_ != &::google::protobuf::internal::kEmptyString) {
    ps_->clear();
  }
  clear_has_ps();
}
inline const ::std::string& AckUpTableSuccess::ps() const {
  return *ps_;
}
inline void AckUpTableSuccess::set_ps(const ::std::string& value) {
  set_has_ps();
  if (ps_ == &::google::protobuf::internal::kEmptyString) {
    ps_ = new ::std::string;
  }
  ps_->assign(value);
}
inline void AckUpTableSuccess::set_ps(const char* value) {
  set_has_ps();
  if (ps_ == &::google::protobuf::internal::kEmptyString) {
    ps_ = new ::std::string;
  }
  ps_->assign(value);
}
inline void AckUpTableSuccess::set_ps(const char* value, size_t size) {
  set_has_ps();
  if (ps_ == &::google::protobuf::internal::kEmptyString) {
    ps_ = new ::std::string;
  }
  ps_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckUpTableSuccess::mutable_ps() {
  set_has_ps();
  if (ps_ == &::google::protobuf::internal::kEmptyString) {
    ps_ = new ::std::string;
  }
  return ps_;
}
inline ::std::string* AckUpTableSuccess::release_ps() {
  clear_has_ps();
  if (ps_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ps_;
    ps_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckUpTableSuccess::set_allocated_ps(::std::string* ps) {
  if (ps_ != &::google::protobuf::internal::kEmptyString) {
    delete ps_;
  }
  if (ps) {
    set_has_ps();
    ps_ = ps;
  } else {
    clear_has_ps();
    ps_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckUpTableErrorUc

// required int32 uid = 1;
inline bool AckUpTableErrorUc::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUpTableErrorUc::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUpTableErrorUc::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUpTableErrorUc::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckUpTableErrorUc::uid() const {
  return uid_;
}
inline void AckUpTableErrorUc::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 money = 2;
inline bool AckUpTableErrorUc::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUpTableErrorUc::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUpTableErrorUc::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUpTableErrorUc::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckUpTableErrorUc::money() const {
  return money_;
}
inline void AckUpTableErrorUc::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 code = 3;
inline bool AckUpTableErrorUc::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckUpTableErrorUc::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckUpTableErrorUc::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckUpTableErrorUc::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 AckUpTableErrorUc::code() const {
  return code_;
}
inline void AckUpTableErrorUc::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// AckAheadDownTable

// required int32 uid = 1;
inline bool AckAheadDownTable::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckAheadDownTable::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckAheadDownTable::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckAheadDownTable::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckAheadDownTable::uid() const {
  return uid_;
}
inline void AckAheadDownTable::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 seatid = 2;
inline bool AckAheadDownTable::has_seatid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckAheadDownTable::set_has_seatid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckAheadDownTable::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckAheadDownTable::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckAheadDownTable::seatid() const {
  return seatid_;
}
inline void AckAheadDownTable::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 down_tag = 3;
inline bool AckAheadDownTable::has_down_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckAheadDownTable::set_has_down_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckAheadDownTable::clear_has_down_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckAheadDownTable::clear_down_tag() {
  down_tag_ = 0;
  clear_has_down_tag();
}
inline ::google::protobuf::int32 AckAheadDownTable::down_tag() const {
  return down_tag_;
}
inline void AckAheadDownTable::set_down_tag(::google::protobuf::int32 value) {
  set_has_down_tag();
  down_tag_ = value;
}

// -------------------------------------------------------------------

// AckDownTableSuccess

// required int32 uid = 1;
inline bool AckDownTableSuccess::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckDownTableSuccess::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckDownTableSuccess::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckDownTableSuccess::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AckDownTableSuccess::uid() const {
  return uid_;
}
inline void AckDownTableSuccess::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 seatid = 2;
inline bool AckDownTableSuccess::has_seatid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckDownTableSuccess::set_has_seatid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckDownTableSuccess::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckDownTableSuccess::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckDownTableSuccess::seatid() const {
  return seatid_;
}
inline void AckDownTableSuccess::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 money = 3;
inline bool AckDownTableSuccess::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckDownTableSuccess::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckDownTableSuccess::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckDownTableSuccess::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckDownTableSuccess::money() const {
  return money_;
}
inline void AckDownTableSuccess::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// AckUpTableInfoReq

// required int32 start_index = 1;
inline bool AckUpTableInfoReq::has_start_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUpTableInfoReq::set_has_start_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUpTableInfoReq::clear_has_start_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUpTableInfoReq::clear_start_index() {
  start_index_ = 0;
  clear_has_start_index();
}
inline ::google::protobuf::int32 AckUpTableInfoReq::start_index() const {
  return start_index_;
}
inline void AckUpTableInfoReq::set_start_index(::google::protobuf::int32 value) {
  set_has_start_index();
  start_index_ = value;
}

// optional int32 end_index = 2;
inline bool AckUpTableInfoReq::has_end_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUpTableInfoReq::set_has_end_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUpTableInfoReq::clear_has_end_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUpTableInfoReq::clear_end_index() {
  end_index_ = 0;
  clear_has_end_index();
}
inline ::google::protobuf::int32 AckUpTableInfoReq::end_index() const {
  return end_index_;
}
inline void AckUpTableInfoReq::set_end_index(::google::protobuf::int32 value) {
  set_has_end_index();
  end_index_ = value;
}

// -------------------------------------------------------------------

// AckUpTableInfo_UC

// repeated .proto.login.tagPlayers players = 1;
inline int AckUpTableInfo_UC::players_size() const {
  return players_.size();
}
inline void AckUpTableInfo_UC::clear_players() {
  players_.Clear();
}
inline const ::proto::login::tagPlayers& AckUpTableInfo_UC::players(int index) const {
  return players_.Get(index);
}
inline ::proto::login::tagPlayers* AckUpTableInfo_UC::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::proto::login::tagPlayers* AckUpTableInfo_UC::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >&
AckUpTableInfo_UC::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >*
AckUpTableInfo_UC::mutable_players() {
  return &players_;
}

// optional int32 rank = 2;
inline bool AckUpTableInfo_UC::has_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUpTableInfo_UC::set_has_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUpTableInfo_UC::clear_has_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUpTableInfo_UC::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 AckUpTableInfo_UC::rank() const {
  return rank_;
}
inline void AckUpTableInfo_UC::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional int32 number = 3;
inline bool AckUpTableInfo_UC::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckUpTableInfo_UC::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckUpTableInfo_UC::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckUpTableInfo_UC::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 AckUpTableInfo_UC::number() const {
  return number_;
}
inline void AckUpTableInfo_UC::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// optional int32 down_tag = 4;
inline bool AckUpTableInfo_UC::has_down_tag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckUpTableInfo_UC::set_has_down_tag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckUpTableInfo_UC::clear_has_down_tag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckUpTableInfo_UC::clear_down_tag() {
  down_tag_ = 0;
  clear_has_down_tag();
}
inline ::google::protobuf::int32 AckUpTableInfo_UC::down_tag() const {
  return down_tag_;
}
inline void AckUpTableInfo_UC::set_down_tag(::google::protobuf::int32 value) {
  set_has_down_tag();
  down_tag_ = value;
}

// optional int32 limit_money = 5;
inline bool AckUpTableInfo_UC::has_limit_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckUpTableInfo_UC::set_has_limit_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckUpTableInfo_UC::clear_has_limit_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckUpTableInfo_UC::clear_limit_money() {
  limit_money_ = 0;
  clear_has_limit_money();
}
inline ::google::protobuf::int32 AckUpTableInfo_UC::limit_money() const {
  return limit_money_;
}
inline void AckUpTableInfo_UC::set_limit_money(::google::protobuf::int32 value) {
  set_has_limit_money();
  limit_money_ = value;
}

// optional int32 stand_money = 6;
inline bool AckUpTableInfo_UC::has_stand_money() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckUpTableInfo_UC::set_has_stand_money() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckUpTableInfo_UC::clear_has_stand_money() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckUpTableInfo_UC::clear_stand_money() {
  stand_money_ = 0;
  clear_has_stand_money();
}
inline ::google::protobuf::int32 AckUpTableInfo_UC::stand_money() const {
  return stand_money_;
}
inline void AckUpTableInfo_UC::set_stand_money(::google::protobuf::int32 value) {
  set_has_stand_money();
  stand_money_ = value;
}

// optional int32 base_money = 7;
inline bool AckUpTableInfo_UC::has_base_money() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckUpTableInfo_UC::set_has_base_money() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckUpTableInfo_UC::clear_has_base_money() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckUpTableInfo_UC::clear_base_money() {
  base_money_ = 0;
  clear_has_base_money();
}
inline ::google::protobuf::int32 AckUpTableInfo_UC::base_money() const {
  return base_money_;
}
inline void AckUpTableInfo_UC::set_base_money(::google::protobuf::int32 value) {
  set_has_base_money();
  base_money_ = value;
}

// optional int32 left_len = 8;
inline bool AckUpTableInfo_UC::has_left_len() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckUpTableInfo_UC::set_has_left_len() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckUpTableInfo_UC::clear_has_left_len() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckUpTableInfo_UC::clear_left_len() {
  left_len_ = 0;
  clear_has_left_len();
}
inline ::google::protobuf::int32 AckUpTableInfo_UC::left_len() const {
  return left_len_;
}
inline void AckUpTableInfo_UC::set_left_len(::google::protobuf::int32 value) {
  set_has_left_len();
  left_len_ = value;
}

// -------------------------------------------------------------------

// AckUpTableInfo_BC

// repeated .proto.login.tagPlayers players = 1;
inline int AckUpTableInfo_BC::players_size() const {
  return players_.size();
}
inline void AckUpTableInfo_BC::clear_players() {
  players_.Clear();
}
inline const ::proto::login::tagPlayers& AckUpTableInfo_BC::players(int index) const {
  return players_.Get(index);
}
inline ::proto::login::tagPlayers* AckUpTableInfo_BC::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::proto::login::tagPlayers* AckUpTableInfo_BC::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >&
AckUpTableInfo_BC::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >*
AckUpTableInfo_BC::mutable_players() {
  return &players_;
}

// -------------------------------------------------------------------

// AckAllLookOnUserResp

// repeated .proto.login.tagPlayers players = 1;
inline int AckAllLookOnUserResp::players_size() const {
  return players_.size();
}
inline void AckAllLookOnUserResp::clear_players() {
  players_.Clear();
}
inline const ::proto::login::tagPlayers& AckAllLookOnUserResp::players(int index) const {
  return players_.Get(index);
}
inline ::proto::login::tagPlayers* AckAllLookOnUserResp::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::proto::login::tagPlayers* AckAllLookOnUserResp::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >&
AckAllLookOnUserResp::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::login::tagPlayers >*
AckAllLookOnUserResp::mutable_players() {
  return &players_;
}

// optional int32 left_len = 2;
inline bool AckAllLookOnUserResp::has_left_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckAllLookOnUserResp::set_has_left_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckAllLookOnUserResp::clear_has_left_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckAllLookOnUserResp::clear_left_len() {
  left_len_ = 0;
  clear_has_left_len();
}
inline ::google::protobuf::int32 AckAllLookOnUserResp::left_len() const {
  return left_len_;
}
inline void AckAllLookOnUserResp::set_left_len(::google::protobuf::int32 value) {
  set_has_left_len();
  left_len_ = value;
}

// -------------------------------------------------------------------

// AckHeatBeat

// required int32 state = 1;
inline bool AckHeatBeat::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckHeatBeat::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckHeatBeat::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckHeatBeat::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 AckHeatBeat::state() const {
  return state_;
}
inline void AckHeatBeat::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// AckPrereadyBC

// required int32 roomid = 1;
inline bool AckPrereadyBC::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPrereadyBC::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPrereadyBC::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPrereadyBC::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 AckPrereadyBC::roomid() const {
  return roomid_;
}
inline void AckPrereadyBC::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
}

// -------------------------------------------------------------------

// AckEmotionBC

// required int32 seatid = 1;
inline bool AckEmotionBC::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckEmotionBC::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckEmotionBC::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckEmotionBC::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckEmotionBC::seatid() const {
  return seatid_;
}
inline void AckEmotionBC::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional int32 money = 2;
inline bool AckEmotionBC::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckEmotionBC::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckEmotionBC::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckEmotionBC::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckEmotionBC::money() const {
  return money_;
}
inline void AckEmotionBC::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 target_seatid = 3;
inline bool AckEmotionBC::has_target_seatid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckEmotionBC::set_has_target_seatid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckEmotionBC::clear_has_target_seatid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckEmotionBC::clear_target_seatid() {
  target_seatid_ = 0;
  clear_has_target_seatid();
}
inline ::google::protobuf::int32 AckEmotionBC::target_seatid() const {
  return target_seatid_;
}
inline void AckEmotionBC::set_target_seatid(::google::protobuf::int32 value) {
  set_has_target_seatid();
  target_seatid_ = value;
}

// optional int32 target_seat_num = 4;
inline bool AckEmotionBC::has_target_seat_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckEmotionBC::set_has_target_seat_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckEmotionBC::clear_has_target_seat_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckEmotionBC::clear_target_seat_num() {
  target_seat_num_ = 0;
  clear_has_target_seat_num();
}
inline ::google::protobuf::int32 AckEmotionBC::target_seat_num() const {
  return target_seat_num_;
}
inline void AckEmotionBC::set_target_seat_num(::google::protobuf::int32 value) {
  set_has_target_seat_num();
  target_seat_num_ = value;
}

// optional int32 type = 5;
inline bool AckEmotionBC::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckEmotionBC::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckEmotionBC::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckEmotionBC::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AckEmotionBC::type() const {
  return type_;
}
inline void AckEmotionBC::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// AckChatBC

// required int32 seatid = 1;
inline bool AckChatBC::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckChatBC::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckChatBC::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckChatBC::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 AckChatBC::seatid() const {
  return seatid_;
}
inline void AckChatBC::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
}

// optional string charmsg = 2;
inline bool AckChatBC::has_charmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckChatBC::set_has_charmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckChatBC::clear_has_charmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckChatBC::clear_charmsg() {
  if (charmsg_ != &::google::protobuf::internal::kEmptyString) {
    charmsg_->clear();
  }
  clear_has_charmsg();
}
inline const ::std::string& AckChatBC::charmsg() const {
  return *charmsg_;
}
inline void AckChatBC::set_charmsg(const ::std::string& value) {
  set_has_charmsg();
  if (charmsg_ == &::google::protobuf::internal::kEmptyString) {
    charmsg_ = new ::std::string;
  }
  charmsg_->assign(value);
}
inline void AckChatBC::set_charmsg(const char* value) {
  set_has_charmsg();
  if (charmsg_ == &::google::protobuf::internal::kEmptyString) {
    charmsg_ = new ::std::string;
  }
  charmsg_->assign(value);
}
inline void AckChatBC::set_charmsg(const char* value, size_t size) {
  set_has_charmsg();
  if (charmsg_ == &::google::protobuf::internal::kEmptyString) {
    charmsg_ = new ::std::string;
  }
  charmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckChatBC::mutable_charmsg() {
  set_has_charmsg();
  if (charmsg_ == &::google::protobuf::internal::kEmptyString) {
    charmsg_ = new ::std::string;
  }
  return charmsg_;
}
inline ::std::string* AckChatBC::release_charmsg() {
  clear_has_charmsg();
  if (charmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charmsg_;
    charmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckChatBC::set_allocated_charmsg(::std::string* charmsg) {
  if (charmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete charmsg_;
  }
  if (charmsg) {
    set_has_charmsg();
    charmsg_ = charmsg;
  } else {
    clear_has_charmsg();
    charmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace login
}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_loginproto_2eproto__INCLUDED
